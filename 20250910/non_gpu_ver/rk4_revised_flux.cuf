! Assumption 1. u is treated as a constant when taking spatial derivatives
! Assumption 2. Time Independent
! Assumption 3. mu is an invariant. That is, u and mu are declared at initialization
! Assumption 4. The sign of sqrt{g} is not corrected


! Revised on 20250919 : Added precomputed sine values
! 11s/1e5 steps
program main
    use set_values
    use fourier3
    use nc_reader
    use cubic_spline_mod
    use spline2_mod
    use trig_compute

    implicit none
    type(nc_data) :: nc

    real(8) :: deltax
    real(8) :: dudt,v,g    ! Updated scalars (u=v_parallel, mu=magnetic moment)
    real(8) :: b_para_n, b_n(3), bsup(3), bsub(3), b_abs, e_n(3), x(3), dxdt(3), grad_b(3)
    real(8) :: j(3)    ! current density(contravariant)
    real(8) :: x_1(3), x_2(3), x_3(3), x_4(3),  u_1, u_2, u_3, u_4
    real(8) :: x_temp(3), u_temp
    real(8) :: bxgb(3)

    real(8) :: r, z, zeta, dx, dx2, dx3

    integer :: sindex  ! zipper for writing(1 write for every 'zipper' steps)

!!!! Below are variables for storing spline coefficients
!!!! for spline3 coeffs

    ! for cuda kernels


    real(8), allocatable :: b_abs_a(:,:), b_abs_b(:,:), b_abs_c(:,:), b_abs_d(:,:)
    real(8), allocatable :: b_abs_arr(:), b_abs_ds_arr(:)
    real(8), allocatable :: g_a(:,:), g_b(:,:), g_c(:,:), g_d(:,:)
    real(8), allocatable :: g_arr(:)

    real(8), allocatable :: bsubs_a(:,:), bsubs_b(:,:), bsubs_c(:,:), bsubs_d(:,:)
    real(8), allocatable :: bsubs_arr(:)
    real(8), allocatable :: bsubu_a(:,:), bsubu_b(:,:), bsubu_c(:,:), bsubu_d(:,:)
    real(8), allocatable :: bsubu_arr(:)
    real(8), allocatable :: bsubv_a(:,:), bsubv_b(:,:), bsubv_c(:,:), bsubv_d(:,:)
    real(8), allocatable :: bsubv_arr(:)

    real(8), allocatable :: bsupu_a(:,:), bsupu_b(:,:), bsupu_c(:,:), bsupu_d(:,:)
    real(8), allocatable :: bsupu_arr(:)
    real(8), allocatable :: bsupv_a(:,:), bsupv_b(:,:), bsupv_c(:,:), bsupv_d(:,:)
    real(8), allocatable :: bsupv_arr(:)

    real(8), allocatable :: rmnc_a(:,:), rmnc_b(:,:), rmnc_c(:,:), rmnc_d(:,:)
    real(8), allocatable :: rmnc_arr(:)
    real(8), allocatable :: zmns_a(:,:), zmns_b(:,:), zmns_c(:,:), zmns_d(:,:)
    real(8), allocatable :: zmns_arr(:)

    real(8), allocatable :: currumnc_a(:,:), currumnc_b(:,:), currumnc_c(:,:), currumnc_d(:,:)
    real(8), allocatable :: currumnc_arr(:)
    real(8), allocatable :: currvmnc_a(:,:), currvmnc_b(:,:), currvmnc_c(:,:), currvmnc_d(:,:)
    real(8), allocatable :: currvmnc_arr(:)


    !! revised on 20250910 : added variables for precomputed sine, cosine values
    real(8), allocatable :: cosvals(:), sinvals(:), cosvals_nyq(:), sinvals_nyq(:)

    integer :: n_nyq, n_mn


!!! for euler method setting

    INTEGER :: istep, jstep, kstep, lstep, unit_out


    integer :: istat



    ! time measurement variables
    integer :: time_start, time_end, clock_rate
    real(8) :: elapsed

    call system_clock(time_start, clock_rate)

    call init_val()


    
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Header
    unit_out = 10
    open(unit=unit_out, file=filename, status="replace", action="write", form="formatted")
    write(unit_out,*) "sig=", sig

    write(unit_out,*) "dt=", dt
    write(unit_out,*) "steps=", steps
    write(unit_out,*) "x0=", x0
    write(unit_out,*) "u=", u
    write(unit_out,*) "v_perp=", v_perp
    write(unit_out,*)
    write(unit_out,'(A)') "istep        s       theta        zeta"

!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    call read_nc("wout_iota0_42.nc", nc)
    deltax=nc%phi(2)-nc%phi(1)
    v=sqrt(u**2+v_perp**2)
    n_nyq = nc%mnmax_nyq
    n_mn  = nc%mnmax
! coeffs



! coeffs



    ! Allocating spline3 coeff arrays
    allocate(b_abs_a(nc%mnmax_nyq, nc%ns), b_abs_b(nc%mnmax_nyq, nc%ns-1), &
    b_abs_c(nc%mnmax_nyq, nc%ns), b_abs_d(nc%mnmax_nyq, nc%ns-1))
    allocate(g_a(nc%mnmax_nyq, nc%ns), g_b(nc%mnmax_nyq, nc%ns-1), &
    g_c(nc%mnmax_nyq, nc%ns), g_d(nc%mnmax_nyq, nc%ns-1))

    allocate(bsubs_a(nc%mnmax_nyq, nc%ns), bsubs_b(nc%mnmax_nyq, nc%ns-1), &
    bsubs_c(nc%mnmax_nyq, nc%ns), bsubs_d(nc%mnmax_nyq, nc%ns-1))
    allocate(bsubu_a(nc%mnmax_nyq, nc%ns), bsubu_b(nc%mnmax_nyq, nc%ns-1), &
    bsubu_c(nc%mnmax_nyq, nc%ns), bsubu_d(nc%mnmax_nyq, nc%ns-1))
    allocate(bsubv_a(nc%mnmax_nyq, nc%ns), bsubv_b(nc%mnmax_nyq, nc%ns-1), &
    bsubv_c(nc%mnmax_nyq, nc%ns), bsubv_d(nc%mnmax_nyq, nc%ns-1))

    allocate(bsupu_a(nc%mnmax_nyq, nc%ns), bsupu_b(nc%mnmax_nyq, nc%ns-1), &
    bsupu_c(nc%mnmax_nyq, nc%ns), bsupu_d(nc%mnmax_nyq, nc%ns-1))
    allocate(bsupv_a(nc%mnmax_nyq, nc%ns), bsupv_b(nc%mnmax_nyq, nc%ns-1), &
    bsupv_c(nc%mnmax_nyq, nc%ns), bsupv_d(nc%mnmax_nyq, nc%ns-1))


    allocate(rmnc_a(nc%mnmax, nc%ns), rmnc_b(nc%mnmax, nc%ns-1), &
    rmnc_c(nc%mnmax, nc%ns), rmnc_d(nc%mnmax, nc%ns-1))
    allocate(zmns_a(nc%mnmax, nc%ns), zmns_b(nc%mnmax, nc%ns-1), &
    zmns_c(nc%mnmax, nc%ns), zmns_d(nc%mnmax, nc%ns-1))



    allocate(b_abs_arr(nc%mnmax_nyq), b_abs_ds_arr(nc%mnmax_nyq), g_arr(nc%mnmax_nyq), &
    bsubs_arr(nc%mnmax_nyq), bsubu_arr(nc%mnmax_nyq), bsubv_arr(nc%mnmax_nyq), &
    bsupu_arr(nc%mnmax_nyq), bsupv_arr(nc%mnmax_nyq), &
    rmnc_arr(nc%mnmax), zmns_arr(nc%mnmax))

    allocate(currumnc_a(nc%mnmax_nyq, nc%ns), currumnc_b(nc%mnmax_nyq, nc%ns-1), & 
    currumnc_c(nc%mnmax_nyq, nc%ns), currumnc_d(nc%mnmax_nyq, nc%ns-1))
    allocate(currvmnc_a(nc%mnmax_nyq, nc%ns), currvmnc_b(nc%mnmax_nyq, nc%ns-1), &
    currvmnc_c(nc%mnmax_nyq, nc%ns), currvmnc_d(nc%mnmax_nyq, nc%ns-1))
    allocate(currumnc_arr(nc%mnmax_nyq), currvmnc_arr(nc%mnmax_nyq))
    ! End of allocating spline3 coeff arrays
    
    !saving spline3 coeffs

    ! for test
    allocate(cosvals(nc%mnmax), sinvals(nc%mnmax), cosvals_nyq(nc%mnmax_nyq), sinvals_nyq(nc%mnmax_nyq))
    
    !saving spline3 coeffs

    do jstep=1, nc%mnmax_nyq
        call spline_getter(deltax, nc%bmnc(jstep, :), b_abs_a(jstep, :), b_abs_b(jstep, :), &
        b_abs_c(jstep, :), b_abs_d(jstep, :))
        call spline_getter(deltax, nc%gmnc(jstep, :), g_a(jstep, :), g_b(jstep, :), &
        g_c(jstep, :), g_d(jstep, :))
        call spline_getter(deltax, nc%bsubsmns(jstep, :), bsubs_a(jstep, :), bsubs_b(jstep, :), &
        bsubs_c(jstep, :), bsubs_d(jstep, :))
        call spline_getter(deltax, nc%bsubumnc(jstep, :), bsubu_a(jstep, :), bsubu_b(jstep, :), &
        bsubu_c(jstep, :), bsubu_d(jstep, :))
        call spline_getter(deltax, nc%bsubvmnc(jstep, :), bsubv_a(jstep, :), bsubv_b(jstep, :), &
        bsubv_c(jstep, :), bsubv_d(jstep, :))
        call spline_getter(deltax, nc%bsupumnc(jstep, :), bsupu_a(jstep, :), bsupu_b(jstep, :), &
        bsupu_c(jstep, :), bsupu_d(jstep, :))
        call spline_getter(deltax, nc%bsupvmnc(jstep, :), bsupv_a(jstep, :), bsupv_b(jstep, :), &
        bsupv_c(jstep, :), bsupv_d(jstep, :))

        call spline_getter(deltax, nc%currumnc(jstep, :), currumnc_a(jstep, :), currumnc_b(jstep, :), &
        currumnc_c(jstep, :), currumnc_d(jstep, :))
        call spline_getter(deltax, nc%currvmnc(jstep, :), currvmnc_a(jstep, :), currvmnc_b(jstep, :), &
        currvmnc_c(jstep, :), currvmnc_d(jstep, :))




    end do

    do jstep=1, nc%mnmax
        call spline_getter(deltax, nc%rmnc(jstep, :), rmnc_a(jstep, :), rmnc_b(jstep, :), &
        rmnc_c(jstep, :), rmnc_d(jstep, :))
        call spline_getter(deltax, nc%zmns(jstep, :), zmns_a(jstep, :), zmns_b(jstep, :), &
        zmns_c(jstep, :), zmns_d(jstep, :))
    end do

        ! end of saving spline3 coeffs.


! Numerical integration using rk4 method

    do istep=1,steps
        

        x_temp=x0
        u_temp=u
        !!!!!!!! RK4 1st

        ! Getting range index of s
        sindex=int(x0(1)/deltax)+1
        if (sindex < 1) sindex = 1
        if (sindex > nc%ns-1) sindex = nc%ns-1
        dx=x0(1)-nc%phi(sindex)

        do kstep=1,nc%mnmax_nyq
            b_abs_arr(kstep)=b_abs_d(kstep,sindex)*(dx**3)+b_abs_c(kstep,sindex)*(dx**2)+b_abs_b(kstep,sindex)*dx+b_abs_a(kstep,sindex)
            b_abs_ds_arr(kstep)=3.0d0*b_abs_d(kstep,sindex)*(dx**2)+2.0d0*b_abs_c(kstep,sindex)*dx+b_abs_b(kstep,sindex)

            g_arr(kstep)=g_d(kstep,sindex)*(dx**3)+g_c(kstep,sindex)*(dx**2)+g_b(kstep,sindex)*dx+g_a(kstep,sindex)
            bsubs_arr(kstep)=bsubs_d(kstep,sindex)*(dx**3)+bsubs_c(kstep,sindex)*(dx**2)+bsubs_b(kstep,sindex)*dx+bsubs_a(kstep,sindex)
            bsubu_arr(kstep)=bsubu_d(kstep,sindex)*(dx**3)+bsubu_c(kstep,sindex)*(dx**2)+bsubu_b(kstep,sindex)*dx+bsubu_a(kstep,sindex)
            bsubv_arr(kstep)=bsubv_d(kstep,sindex)*(dx**3)+bsubv_c(kstep,sindex)*(dx**2)+bsubv_b(kstep,sindex)*dx+bsubv_a(kstep,sindex)

            bsupu_arr(kstep)=bsupu_d(kstep,sindex)*(dx**3)+bsupu_c(kstep,sindex)*(dx**2)+bsupu_b(kstep,sindex)*dx+bsupu_a(kstep,sindex) 
            bsupv_arr(kstep)=bsupv_d(kstep,sindex)*(dx**3)+bsupv_c(kstep,sindex)*(dx**2)+bsupv_b(kstep,sindex)*dx+bsupv_a(kstep,sindex) 

            currumnc_arr(kstep)=currumnc_d(kstep,sindex)*(dx**3)+currumnc_c(kstep,sindex)*(dx**2)+currumnc_b(kstep,sindex)*dx+currumnc_a(kstep,sindex)
            currvmnc_arr(kstep)=currvmnc_d(kstep,sindex)*(dx**3)+currvmnc_c(kstep,sindex)*(dx**2)+currvmnc_b(kstep,sindex)*dx+currvmnc_a(kstep,sindex)

        end do
    
        do lstep=1,nc%mnmax
            rmnc_arr(lstep)=rmnc_d(lstep,sindex)*(dx**3)+rmnc_c(lstep,sindex)*(dx**2)+rmnc_b(lstep,sindex)*dx+rmnc_a(lstep,sindex)
            zmns_arr(lstep)=zmns_d(lstep,sindex)*(dx**3)+zmns_c(lstep,sindex)*(dx**2)+zmns_b(lstep,sindex)*dx+zmns_a(lstep,sindex)
        end do        

        call compute_trig(x0(2), x0(3), nc%xm, nc%xn, sinvals, cosvals)  ! precomputing sine, cosine values for mnmax
        call compute_trig(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, sinvals_nyq, cosvals_nyq)  ! precomputing sine, cosine values for mnmax_nyq
        !!!!!!!!!!!!! Writing r,z, zeta   !!!!!!!!!!!!!!!!
        r=compc_arg(x0(2), x0(3), nc%xm, nc%xn, rmnc_arr, cosvals)
        z=comps_arg(x0(2), x0(3), nc%xm, nc%xn, zmns_arr, cosvals)

        if (mod(istep,zipper)==0) then
            write(unit_out,'(I8,3ES20.10)') istep,x0(1),x0(2),x0(3)
        end if


        grad_b(1)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, b_abs_ds_arr, cosvals_nyq)
        grad_b(2)=compc_dtheta_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, b_abs_arr, sinvals_nyq)
        grad_b(3)=compc_dzeta_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, b_abs_arr, sinvals_nyq)

        bsub(1)=comps_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsubs_arr, sinvals_nyq)
        bsub(2)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsubu_arr, cosvals_nyq)
        bsub(3)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsubv_arr, cosvals_nyq)
        bsup(1)=0.0d0
        bsup(2)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsupu_arr, cosvals_nyq)
        bsup(3)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsupv_arr, cosvals_nyq)
        b_abs=compc_arg(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, b_abs_arr, cosvals_nyq)
        g=compc_arg(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, g_arr, cosvals_nyq)

        j(1)=0.0d0
        j(2)=compc_arg(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, currumnc_arr, cosvals_nyq)
        j(3)=compc_arg(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, currvmnc_arr, cosvals_nyq)

        call crossp2(bsub, grad_b, sig*g, bxgb)  ! saving b x grad_b in bxgb

        b_n=bsup+eps*u*((mu0*j/b_abs)+(bxgb/(b_abs**2)))  ! row 1
        b_para_n=(b_abs+eps*u*(mu0*DOT_PRODUCT(j,bsub)/(b_abs**2)))   ! row 2
        dudt=-(v_perp_2/(2.0d0*b_abs))*DOT_PRODUCT(grad_b,bsup)/b_para_n  ! row 3
        dxdt=(b_abs/b_para_n)*((u*b_n/b_abs)+(m*v_perp_2/(2*q*(b_abs**3)))*bxgb)
        
        x_1=dxdt
        u_1=dudt
        x0=x_temp+0.5d0*x_1*dt
        u=u_temp+0.5d0*u_1*dt

        !!!!!!!! RK4 2nd

        
        ! Getting range index of s
        sindex=int(x0(1)/deltax)+1
        if (sindex < 1) sindex = 1
        if (sindex > nc%ns-1) sindex = nc%ns-1
        dx=x0(1)-nc%phi(sindex)

        do kstep=1,nc%mnmax_nyq
            b_abs_arr(kstep)=b_abs_d(kstep,sindex)*(dx**3)+b_abs_c(kstep,sindex)*(dx**2)+b_abs_b(kstep,sindex)*dx+b_abs_a(kstep,sindex)
            b_abs_ds_arr(kstep)=3.0d0*b_abs_d(kstep,sindex)*(dx**2)+2.0d0*b_abs_c(kstep,sindex)*dx+b_abs_b(kstep,sindex)

            g_arr(kstep)=g_d(kstep,sindex)*(dx**3)+g_c(kstep,sindex)*(dx**2)+g_b(kstep,sindex)*dx+g_a(kstep,sindex)
            bsubs_arr(kstep)=bsubs_d(kstep,sindex)*(dx**3)+bsubs_c(kstep,sindex)*(dx**2)+bsubs_b(kstep,sindex)*dx+bsubs_a(kstep,sindex)
            bsubu_arr(kstep)=bsubu_d(kstep,sindex)*(dx**3)+bsubu_c(kstep,sindex)*(dx**2)+bsubu_b(kstep,sindex)*dx+bsubu_a(kstep,sindex)
            bsubv_arr(kstep)=bsubv_d(kstep,sindex)*(dx**3)+bsubv_c(kstep,sindex)*(dx**2)+bsubv_b(kstep,sindex)*dx+bsubv_a(kstep,sindex)

            bsupu_arr(kstep)=bsupu_d(kstep,sindex)*(dx**3)+bsupu_c(kstep,sindex)*(dx**2)+bsupu_b(kstep,sindex)*dx+bsupu_a(kstep,sindex) 
            bsupv_arr(kstep)=bsupv_d(kstep,sindex)*(dx**3)+bsupv_c(kstep,sindex)*(dx**2)+bsupv_b(kstep,sindex)*dx+bsupv_a(kstep,sindex) 

            currumnc_arr(kstep)=currumnc_d(kstep,sindex)*(dx**3)+currumnc_c(kstep,sindex)*(dx**2)+currumnc_b(kstep,sindex)*dx+currumnc_a(kstep,sindex)
            currvmnc_arr(kstep)=currvmnc_d(kstep,sindex)*(dx**3)+currvmnc_c(kstep,sindex)*(dx**2)+currvmnc_b(kstep,sindex)*dx+currvmnc_a(kstep,sindex)

        end do
    


        call compute_trig(x0(2), x0(3), nc%xm, nc%xn, sinvals, cosvals)  ! precomputing sine, cosine values for mnmax
        call compute_trig(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, sinvals_nyq, cosvals_nyq)  ! precomputing sine, cosine values for mnmax_nyq


        grad_b(1)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, b_abs_ds_arr, cosvals_nyq)
        grad_b(2)=compc_dtheta_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, b_abs_arr, sinvals_nyq)
        grad_b(3)=compc_dzeta_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, b_abs_arr, sinvals_nyq)

        bsub(1)=comps_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsubs_arr, sinvals_nyq)
        bsub(2)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsubu_arr, cosvals_nyq)
        bsub(3)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsubv_arr, cosvals_nyq)
        bsup(1)=0.0d0
        bsup(2)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsupu_arr, cosvals_nyq)
        bsup(3)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsupv_arr, cosvals_nyq)
        b_abs=compc_arg(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, b_abs_arr, cosvals_nyq)
        g=compc_arg(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, g_arr, cosvals_nyq)

        j(1)=0.0d0
        j(2)=compc_arg(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, currumnc_arr, cosvals_nyq)
        j(3)=compc_arg(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, currvmnc_arr, cosvals_nyq)

        call crossp2(bsub, grad_b, sig*g, bxgb)  ! saving b x grad_b in bxgb

        b_n=bsup+eps*u*((mu0*j/b_abs)+(bxgb/(b_abs**2)))  ! row 1
        b_para_n=b_abs+eps*u*(mu0*DOT_PRODUCT(j,bsub)/(b_abs**2))   ! row 2
        dudt=-(v_perp_2/(2.0d0*b_abs))*DOT_PRODUCT(grad_b,bsup)/b_para_n  ! row 3
        dxdt=(b_abs/b_para_n)*((u*b_n/b_abs)+(m*v_perp_2/(2*q*(b_abs**3)))*bxgb)
        
        x_2=dxdt
        u_2=dudt
        x0=x_temp+0.5d0*x_2*dt
        u=u_temp+0.5d0*u_2*dt

        !!!!!!!!!!! rk4 3rd

        ! Getting range index of s
        sindex=int(x0(1)/deltax)+1
        if (sindex < 1) sindex = 1
        if (sindex > nc%ns-1) sindex = nc%ns-1
        dx=x0(1)-nc%phi(sindex)

        do kstep=1,nc%mnmax_nyq
            b_abs_arr(kstep)=b_abs_d(kstep,sindex)*(dx**3)+b_abs_c(kstep,sindex)*(dx**2)+b_abs_b(kstep,sindex)*dx+b_abs_a(kstep,sindex)
            b_abs_ds_arr(kstep)=3.0d0*b_abs_d(kstep,sindex)*(dx**2)+2.0d0*b_abs_c(kstep,sindex)*dx+b_abs_b(kstep,sindex)

            g_arr(kstep)=g_d(kstep,sindex)*(dx**3)+g_c(kstep,sindex)*(dx**2)+g_b(kstep,sindex)*dx+g_a(kstep,sindex)
            bsubs_arr(kstep)=bsubs_d(kstep,sindex)*(dx**3)+bsubs_c(kstep,sindex)*(dx**2)+bsubs_b(kstep,sindex)*dx+bsubs_a(kstep,sindex)
            bsubu_arr(kstep)=bsubu_d(kstep,sindex)*(dx**3)+bsubu_c(kstep,sindex)*(dx**2)+bsubu_b(kstep,sindex)*dx+bsubu_a(kstep,sindex)
            bsubv_arr(kstep)=bsubv_d(kstep,sindex)*(dx**3)+bsubv_c(kstep,sindex)*(dx**2)+bsubv_b(kstep,sindex)*dx+bsubv_a(kstep,sindex)

            bsupu_arr(kstep)=bsupu_d(kstep,sindex)*(dx**3)+bsupu_c(kstep,sindex)*(dx**2)+bsupu_b(kstep,sindex)*dx+bsupu_a(kstep,sindex) 
            bsupv_arr(kstep)=bsupv_d(kstep,sindex)*(dx**3)+bsupv_c(kstep,sindex)*(dx**2)+bsupv_b(kstep,sindex)*dx+bsupv_a(kstep,sindex) 

            currumnc_arr(kstep)=currumnc_d(kstep,sindex)*(dx**3)+currumnc_c(kstep,sindex)*(dx**2)+currumnc_b(kstep,sindex)*dx+currumnc_a(kstep,sindex)
            currvmnc_arr(kstep)=currvmnc_d(kstep,sindex)*(dx**3)+currvmnc_c(kstep,sindex)*(dx**2)+currvmnc_b(kstep,sindex)*dx+currvmnc_a(kstep,sindex)

        end do
    


        call compute_trig(x0(2), x0(3), nc%xm, nc%xn, sinvals, cosvals)  ! precomputing sine, cosine values for mnmax
        call compute_trig(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, sinvals_nyq, cosvals_nyq)  ! precomputing sine, cosine values for mnmax_nyq

        grad_b(1)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, b_abs_ds_arr, cosvals_nyq)
        grad_b(2)=compc_dtheta_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, b_abs_arr, sinvals_nyq)
        grad_b(3)=compc_dzeta_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, b_abs_arr, sinvals_nyq)

        bsub(1)=comps_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsubs_arr, sinvals_nyq)
        bsub(2)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsubu_arr, cosvals_nyq)
        bsub(3)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsubv_arr, cosvals_nyq)
        bsup(1)=0.0d0
        bsup(2)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsupu_arr, cosvals_nyq)
        bsup(3)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsupv_arr, cosvals_nyq)
        b_abs=compc_arg(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, b_abs_arr, cosvals_nyq)
        g=compc_arg(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, g_arr, cosvals_nyq)

        j(1)=0.0d0
        j(2)=compc_arg(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, currumnc_arr, cosvals_nyq)
        j(3)=compc_arg(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, currvmnc_arr, cosvals_nyq)

        call crossp2(bsub, grad_b, sig*g, bxgb)  ! saving b x grad_b in bxgb

        b_n=bsup+eps*u*((mu0*j/b_abs)+(bxgb/(b_abs**2)))  ! row 1
        b_para_n=b_abs+eps*u*(mu0*DOT_PRODUCT(j,bsub)/(b_abs**2))   ! row 2
        dudt=-(v_perp_2/(2.0d0*b_abs))*DOT_PRODUCT(grad_b,bsup)/b_para_n  ! row 3
        dxdt=(b_abs/b_para_n)*((u*b_n/b_abs)+(m*v_perp_2/(2*q*(b_abs**3)))*bxgb)
        
        x_3=dxdt
        u_3=dudt
        x0=x_temp+x_3*dt
        u=u_temp+u_3*dt

        !!!!!!!!!!! rk4 4th
        ! Getting range index of s
        sindex=int(x0(1)/deltax)+1
        if (sindex < 1) sindex = 1
        if (sindex > nc%ns-1) sindex = nc%ns-1
        dx=x0(1)-nc%phi(sindex)

        do kstep=1,nc%mnmax_nyq
            b_abs_arr(kstep)=b_abs_d(kstep,sindex)*(dx**3)+b_abs_c(kstep,sindex)*(dx**2)+b_abs_b(kstep,sindex)*dx+b_abs_a(kstep,sindex)
            b_abs_ds_arr(kstep)=3.0d0*b_abs_d(kstep,sindex)*(dx**2)+2.0d0*b_abs_c(kstep,sindex)*dx+b_abs_b(kstep,sindex)

            g_arr(kstep)=g_d(kstep,sindex)*(dx**3)+g_c(kstep,sindex)*(dx**2)+g_b(kstep,sindex)*dx+g_a(kstep,sindex)
            bsubs_arr(kstep)=bsubs_d(kstep,sindex)*(dx**3)+bsubs_c(kstep,sindex)*(dx**2)+bsubs_b(kstep,sindex)*dx+bsubs_a(kstep,sindex)
            bsubu_arr(kstep)=bsubu_d(kstep,sindex)*(dx**3)+bsubu_c(kstep,sindex)*(dx**2)+bsubu_b(kstep,sindex)*dx+bsubu_a(kstep,sindex)
            bsubv_arr(kstep)=bsubv_d(kstep,sindex)*(dx**3)+bsubv_c(kstep,sindex)*(dx**2)+bsubv_b(kstep,sindex)*dx+bsubv_a(kstep,sindex)

            bsupu_arr(kstep)=bsupu_d(kstep,sindex)*(dx**3)+bsupu_c(kstep,sindex)*(dx**2)+bsupu_b(kstep,sindex)*dx+bsupu_a(kstep,sindex) 
            bsupv_arr(kstep)=bsupv_d(kstep,sindex)*(dx**3)+bsupv_c(kstep,sindex)*(dx**2)+bsupv_b(kstep,sindex)*dx+bsupv_a(kstep,sindex) 

            currumnc_arr(kstep)=currumnc_d(kstep,sindex)*(dx**3)+currumnc_c(kstep,sindex)*(dx**2)+currumnc_b(kstep,sindex)*dx+currumnc_a(kstep,sindex)
            currvmnc_arr(kstep)=currvmnc_d(kstep,sindex)*(dx**3)+currvmnc_c(kstep,sindex)*(dx**2)+currvmnc_b(kstep,sindex)*dx+currvmnc_a(kstep,sindex)

        end do
    


        call compute_trig(x0(2), x0(3), nc%xm, nc%xn, sinvals, cosvals)  ! precomputing sine, cosine values for mnmax
        call compute_trig(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, sinvals_nyq, cosvals_nyq)  ! precomputing sine, cosine values for mnmax_nyq
        grad_b(1)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, b_abs_ds_arr, cosvals_nyq)
        grad_b(2)=compc_dtheta_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, b_abs_arr, sinvals_nyq)
        grad_b(3)=compc_dzeta_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, b_abs_arr, sinvals_nyq)

        bsub(1)=comps_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsubs_arr, sinvals_nyq)
        bsub(2)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsubu_arr, cosvals_nyq)
        bsub(3)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsubv_arr, cosvals_nyq)
        bsup(1)=0.0d0
        bsup(2)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsupu_arr, cosvals_nyq)
        bsup(3)=compc_arg(x0(2),x0(3),nc%xm_nyq, nc%xn_nyq, bsupv_arr, cosvals_nyq)
        b_abs=compc_arg(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, b_abs_arr, cosvals_nyq)
        g=compc_arg(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, g_arr, cosvals_nyq)

        j(1)=0.0d0
        j(2)=compc_arg(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, currumnc_arr, cosvals_nyq)
        j(3)=compc_arg(x0(2), x0(3), nc%xm_nyq, nc%xn_nyq, currvmnc_arr, cosvals_nyq)

        call crossp2(bsub, grad_b, sig*g, bxgb)  ! saving b x grad_b in bxgb

        b_n=bsup+eps*u*((mu0*j/b_abs)+(bxgb/(b_abs**2)))  ! row 1
        b_para_n=b_abs+eps*u*(mu0*DOT_PRODUCT(j,bsub)/(b_abs**2))   ! row 2
        dudt=-(v_perp_2/(2.0d0*b_abs))*DOT_PRODUCT(grad_b,bsup)/b_para_n  ! row 3
        dxdt=(b_abs/b_para_n)*((u*b_n/b_abs)+(m*v_perp_2/(2*q*(b_abs**3)))*bxgb)
        
        x_4=dxdt
        u_4=dudt


        ! Final update
        x0=x_temp+dt*(x_1+2*x_2+2*x_3+x_4)/6.0d0
        u=u_temp+dt*(u_1+2*u_2+2*u_3+u_4)/6.0d0
        v_perp_2=v**2-u**2

        if (mod(istep,100000)==0) then
            print*, "istep=",  istep
            print*, "grad_b=", grad_b
            print*, "bsub=", bsub
            print*, "bsup=", bsup
            print*, "b_abs=", b_abs
            print*, "g=", g
            print*, "j=", j
            print*, "v_perp_2=", v_perp_2 
            print*, "b_n=", b_n
            print*, "b_para_n=", b_para_n

            print*, "dxdt=", dxdt
            print*, "dudt=", dudt
            print*, "---------------------"
        end if

        

    end do

    call system_clock(time_end)
    elapsed = real(time_end - time_start,8) / real(clock_rate,8)
    print *, 'Elapsed time (seconds): ', elapsed

end program main