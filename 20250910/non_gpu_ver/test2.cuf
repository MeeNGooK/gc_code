! Assumption 1. u is treated as a constant when taking spatial derivatives
! Assumption 2. Time Independent
! Assumption 3. mu is an invariant. That is, u and mu are declared at initialization
! Assumption 4. The sign of sqrt{g} is not corrected

module trigsolver
contains
    attributes(global) subroutine compute_trig(theta, zeta, xm, xn, cosvals, sinvals, n_terms)
        integer, intent(in) :: xm(:), xn(:)
        real(8), value, intent(in) :: theta, zeta
        real(8), intent(out) :: cosvals(:), sinvals(:)
        integer, value, intent(in) :: n_terms
        integer :: i
        
        i=blockIdx%x*blockDim%x + threadIdx%x
        if (i > n_terms) return

        do i = 1, n_terms

            cosvals(i) = cos(xm(i)*theta - (xn(i)*0.5)*zeta)
            sinvals(i) = sin(xm(i)*theta - (xn(i)*0.5)*zeta)
        end do
    end subroutine compute_trig

    subroutine compute_trig_host(theta, zeta, xm, xn, cosvals, sinvals, n_terms)
        integer, intent(in) :: xm(:), xn(:)
        real(8), intent(in) :: theta, zeta
        
        real(8), intent(out) :: cosvals(:), sinvals(:)
        integer, intent(in) :: n_terms
        integer :: i

        do i = 1, n_terms
            cosvals(i) = cos(xm(i)*theta - (xn(i)*0.5)*zeta)
            sinvals(i) = sin(xm(i)*theta - (xn(i)*0.5)*zeta)
        end do
    end subroutine compute_trig_host

end module trigsolver

program main
    use fourier3
    use nc_reader
    use cubic_spline_mod
    use spline2_mod
    use cudafor
    use trigsolver
     ! use fourier2 --- IGNORE ---

    implicit none
    type(nc_data) :: nc
    
    real(8) :: mu0
    real(8) :: m, q, eps, v_perp, v_perp_2,deltax   ! Constants
    real(8) :: x0(3)
    real(8) :: u,dudt,v,g    ! Updated scalars (u=v_parallel, mu=magnetic moment)
    real(8) :: b_para_n, b_n(3), bsup(3), bsub(3), b_abs, e_n(3), x(3), dxdt(3), grad_b(3)
    real(8) :: j(3)    ! current density(contravariant)
    real(8) :: x_1(3), x_2(3), x_3(3), x_4(3),  u_1, u_2, u_3, u_4
    real(8) :: x_temp(3), u_temp
    real(8) :: bxgb(3)

    real(8) :: r, z, zeta, dx
    integer :: sindex, zipper  ! zipper for writing(1 write for every 'zipper' steps)

!!!! Below are variables for storing spline coefficients
!!!! for spline3 coeffs


!!!!!! for test
    integer :: tstep, sstep
    real(8) :: thetat, zetat
    real(8), allocatable :: sinvals(:), cosvals(:)
    real(8), allocatable, device :: sinvals_d(:), cosvals_d(:)
    integer, allocatable, device :: xm_d(:), xn_d(:)
!!! end test




    ! for cuda kernels
    type(dim3) :: tb, gb

    tb = dim3(256, 1, 1)
    gb = dim3((n_nyq + tb%x - 1) / tb%x, 1, 1)

    real(8), allocatable :: b_abs_a(:,:), b_abs_b(:,:), b_abs_c(:,:), b_abs_d(:,:)
    real(8), allocatable :: b_abs_arr(:), b_abs_ds_arr(:)
    real(8), allocatable :: g_a(:,:), g_b(:,:), g_c(:,:), g_d(:,:)
    real(8), allocatable :: g_arr(:)

    real(8), allocatable :: bsubs_a(:,:), bsubs_b(:,:), bsubs_c(:,:), bsubs_d(:,:)
    real(8), allocatable :: bsubs_arr(:)
    real(8), allocatable :: bsubu_a(:,:), bsubu_b(:,:), bsubu_c(:,:), bsubu_d(:,:)
    real(8), allocatable :: bsubu_arr(:)
    real(8), allocatable :: bsubv_a(:,:), bsubv_b(:,:), bsubv_c(:,:), bsubv_d(:,:)
    real(8), allocatable :: bsubv_arr(:)

    real(8), allocatable :: bsupu_a(:,:), bsupu_b(:,:), bsupu_c(:,:), bsupu_d(:,:)
    real(8), allocatable :: bsupu_arr(:)
    real(8), allocatable :: bsupv_a(:,:), bsupv_b(:,:), bsupv_c(:,:), bsupv_d(:,:)
    real(8), allocatable :: bsupv_arr(:)

    real(8), allocatable :: rmnc_a(:,:), rmnc_b(:,:), rmnc_c(:,:), rmnc_d(:,:)
    real(8), allocatable :: rmnc_arr(:)
    real(8), allocatable :: zmns_a(:,:), zmns_b(:,:), zmns_c(:,:), zmns_d(:,:)
    real(8), allocatable :: zmns_arr(:)

    real(8), allocatable :: currumnc_a(:,:), currumnc_b(:,:), currumnc_c(:,:), currumnc_d(:,:)
    real(8), allocatable :: currumnc_arr(:)
    real(8), allocatable :: currvmnc_a(:,:), currvmnc_b(:,:), currvmnc_c(:,:), currvmnc_d(:,:)
    real(8), allocatable :: currvmnc_arr(:)

    

    !!! for device
    real(8), device, allocatable :: b_abs_a_d(:,:), b_abs_b_d(:,:), b_abs_c_d(:,:), b_abs_d_d(:,:)
    real(8), device, allocatable :: g_a_d(:,:), g_b_d(:,:), g_c_d(:,:), g_d_d(:,:)
    real(8), device, allocatable :: bsubs_a_d(:,:), bsubs_b_d(:,:), bsubs_c_d(:,:), bsubs_d_d(:,:)
    real(8), device, allocatable :: bsubu_a_d(:,:), bsubu_b_d(:,:), bsubu_c_d(:,:), bsubu_d_d(:,:)
    real(8), device, allocatable :: bsubv_a_d(:,:), bsubv_b_d(:,:), bsubv_c_d(:,:), bsubv_d_d(:,:)
    real(8), device, allocatable :: bsupu_a_d(:,:), bsupu_b_d(:,:), bsupu_c_d(:,:), bsupu_d_d(:,:)
    real(8), device, allocatable :: bsupv_a_d(:,:), bsupv_b_d(:,:), bsupv_c_d(:,:), bsupv_d_d(:,:)
    real(8), device, allocatable :: currumnc_a_d(:,:), currumnc_b_d(:,:), currumnc_c_d(:,:), currumnc_d_d(:,:)
    real(8), device, allocatable :: currvmnc_a_d(:,:), currvmnc_b_d(:,:), currvmnc_c_d(:,:), currvmnc_d_d(:,:)

    real(8), device, allocatable :: b_abs_arr_d(:), b_abs_ds_arr_d(:), g_arr_d(:)
    real(8), device, allocatable :: bsubs_arr_d(:), bsubu_arr_d(:), bsubv_arr_d(:)
    real(8), device, allocatable :: bsupu_arr_d(:), bsupv_arr_d(:)
    real(8), device, allocatable :: currumnc_arr_d(:), currvmnc_arr_d(:)

    ! rmnc/zmns용도 마찬가지
    real(8), device, allocatable :: rmnc_a_d(:,:), rmnc_b_d(:,:), rmnc_c_d(:,:), rmnc_d_d(:,:)
    real(8), device, allocatable :: zmns_a_d(:,:), zmns_b_d(:,:), zmns_c_d(:,:), zmns_d_d(:,:)
    real(8), device, allocatable :: rmnc_arr_d(:), zmns_arr_d(:)


    integer :: n_nyq, n_mn


!!! for euler method setting

    real(8) :: dt
    INTEGER :: steps, istep, jstep, kstep, lstep, unit_out


    integer :: istat



    ! time measurement variables
    integer :: time_start, time_end, clock_rate
    real(8) :: elapsed

    INTEGER :: sig   ! s, theta, zeta order with eps(s, theta, zeta)=1 (for now)
    call system_clock(time_start, clock_rate)

    istat = cudaDeviceSynchronize()
    if (istat /= 0) then
    print *, "cudaDeviceSynchronize error code = ", istat
    stop
    end if

    sig=1.0d0

    mu0 = 4.0d-7*3.141592653589793d0  ! magnetic permeability of vacuum
    q = 1*1.602176634d-19  ! 전자 전하 electron charge
    m = 1*9.10938356d-31   ! 전자 질량 electron mass
    eps=m/q              ! epsilon

    ! Setting (arbitary values)@@@@@@@@@@@@@@@@@@@@@@@@
    x0=(/0.195, 1.3962, 8.1237/)  !(s, theta, zeta)
    u=2.0d4
    v_perp=6.3d4
    v_perp_2=v_perp**2
    dt=4.0d-10
    steps=500
    zipper=400
    
!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ Header
    unit_out = 10
    open(unit=unit_out, file="dat.dat", status="replace", action="write", form="formatted")
    write(unit_out,*) "sig=", sig

    write(unit_out,*) "dt=", dt
    write(unit_out,*) "steps=", steps
    write(unit_out,*) "x0=", x0
    write(unit_out,*) "u=", u
    write(unit_out,*) "v_perp=", v_perp
    write(unit_out,*)
    write(unit_out,'(A)') "istep          p0              t0              rout            zout"

!@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

    call read_nc("wout_iota0_42.nc", nc)
    deltax=nc%phi(2)-nc%phi(1)
    v=sqrt(u**2+v_perp**2)
    n_nyq = nc%mnmax_nyq
    n_mn  = nc%mnmax
! coeffs
    allocate(b_abs_a_d(n_nyq, nc%ns), b_abs_b_d(n_nyq, nc%ns-1), b_abs_c_d(n_nyq, nc%ns), b_abs_d_d(n_nyq, nc%ns-1))
    allocate(g_a_d(n_nyq, nc%ns),     g_b_d(n_nyq, nc%ns-1),     g_c_d(n_nyq, nc%ns),     g_d_d(n_nyq, nc%ns-1))
    ! ... 동일 패턴으로 bsubs_*, bsubu_*, bsubv_*, bsupu_*, bsupv_*, currumnc_*, currvmnc_* 전부 allocate

    allocate(rmnc_a_d(n_mn, nc%ns), rmnc_b_d(n_mn, nc%ns-1), rmnc_c_d(n_mn, nc%ns), rmnc_d_d(n_mn, nc%ns-1))
    allocate(zmns_a_d(n_mn, nc%ns), zmns_b_d(n_mn, nc%ns-1), zmns_c_d(n_mn, nc%ns), zmns_d_d(n_mn, nc%ns-1))

    ! outputs
    allocate(b_abs_arr_d(n_nyq), b_abs_ds_arr_d(n_nyq), g_arr_d(n_nyq))
    allocate(bsubs_arr_d(n_nyq), bsubu_arr_d(n_nyq), bsubv_arr_d(n_nyq))
    allocate(bsupu_arr_d(n_nyq), bsupv_arr_d(n_nyq))
    allocate(currumnc_arr_d(n_nyq), currvmnc_arr_d(n_nyq))

    allocate(rmnc_arr_d(n_mn), zmns_arr_d(n_mn))


    ! Allocating spline3 coeff arrays
    allocate(b_abs_a(nc%mnmax_nyq, nc%ns), b_abs_b(nc%mnmax_nyq, nc%ns-1), &
    b_abs_c(nc%mnmax_nyq, nc%ns), b_abs_d(nc%mnmax_nyq, nc%ns-1))
    allocate(g_a(nc%mnmax_nyq, nc%ns), g_b(nc%mnmax_nyq, nc%ns-1), &
    g_c(nc%mnmax_nyq, nc%ns), g_d(nc%mnmax_nyq, nc%ns-1))

    allocate(bsubs_a(nc%mnmax_nyq, nc%ns), bsubs_b(nc%mnmax_nyq, nc%ns-1), &
    bsubs_c(nc%mnmax_nyq, nc%ns), bsubs_d(nc%mnmax_nyq, nc%ns-1))
    allocate(bsubu_a(nc%mnmax_nyq, nc%ns), bsubu_b(nc%mnmax_nyq, nc%ns-1), &
    bsubu_c(nc%mnmax_nyq, nc%ns), bsubu_d(nc%mnmax_nyq, nc%ns-1))
    allocate(bsubv_a(nc%mnmax_nyq, nc%ns), bsubv_b(nc%mnmax_nyq, nc%ns-1), &
    bsubv_c(nc%mnmax_nyq, nc%ns), bsubv_d(nc%mnmax_nyq, nc%ns-1))

    allocate(bsupu_a(nc%mnmax_nyq, nc%ns), bsupu_b(nc%mnmax_nyq, nc%ns-1), &
    bsupu_c(nc%mnmax_nyq, nc%ns), bsupu_d(nc%mnmax_nyq, nc%ns-1))
    allocate(bsupv_a(nc%mnmax_nyq, nc%ns), bsupv_b(nc%mnmax_nyq, nc%ns-1), &
    bsupv_c(nc%mnmax_nyq, nc%ns), bsupv_d(nc%mnmax_nyq, nc%ns-1))


    allocate(rmnc_a(nc%mnmax, nc%ns), rmnc_b(nc%mnmax, nc%ns-1), &
    rmnc_c(nc%mnmax, nc%ns), rmnc_d(nc%mnmax, nc%ns-1))
    allocate(zmns_a(nc%mnmax, nc%ns), zmns_b(nc%mnmax, nc%ns-1), &
    zmns_c(nc%mnmax, nc%ns), zmns_d(nc%mnmax, nc%ns-1))



    allocate(b_abs_arr(nc%mnmax_nyq), b_abs_ds_arr(nc%mnmax_nyq), g_arr(nc%mnmax_nyq), &
    bsubs_arr(nc%mnmax_nyq), bsubu_arr(nc%mnmax_nyq), bsubv_arr(nc%mnmax_nyq), &
    bsupu_arr(nc%mnmax_nyq), bsupv_arr(nc%mnmax_nyq), &
    rmnc_arr(nc%mnmax), zmns_arr(nc%mnmax))

    allocate(currumnc_a(nc%mnmax_nyq, nc%ns), currumnc_b(nc%mnmax_nyq, nc%ns-1), & 
    currumnc_c(nc%mnmax_nyq, nc%ns), currumnc_d(nc%mnmax_nyq, nc%ns-1))
    allocate(currvmnc_a(nc%mnmax_nyq, nc%ns), currvmnc_b(nc%mnmax_nyq, nc%ns-1), &
    currvmnc_c(nc%mnmax_nyq, nc%ns), currvmnc_d(nc%mnmax_nyq, nc%ns-1))
    allocate(currumnc_arr(nc%mnmax_nyq), currvmnc_arr(nc%mnmax_nyq))
    ! End of allocating spline3 coeff arrays
    

    ! for test
    allocate(sinvals(n_nyq), cosvals(n_nyq))
    allocate(sinvals_d(n_nyq), cosvals_d(n_nyq))
    allocate(xm_d(n_nyq), xn_d(n_nyq))
    ! 여기서부터 시작
    xm_d = nc%xm_nyq
    xn_d = nc%xn_nyq

    do tstep=1, 1000

        thetat = 0.03522d0 + 0.1d0*tstep
        zetat = 0.5427742d0 + 0.2d0*tstep
        call compute_trig<<<tb,gb>>>(thetat, zetat, xm_d, xn_d, cosvals_d, sinvals_d, n_nyq)
        cosvals = cosvals_d
        sinvals = sinvals_d
        

    end do



    !saving spline3 coeffs

    call system_clock(time_end)
    elapsed = real(time_end - time_start,8) / real(clock_rate,8)
    print *, 'Elapsed time (seconds): ', elapsed

end program main