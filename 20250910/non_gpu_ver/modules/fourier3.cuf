module fourier3
    implicit none
    ! 만약 필요하다면 sin계수의 미분도 만들자
    ! if needed, add some functions for sin coefficients
    !여기서는 cos의 값을 미리 받아 단순 계산으로 변환
    ! here, we precompute the value of cos to reduce computation
contains
    function compc(xs, s, theta, zeta,xm,xn,coeff, cosvals) result(output)   ! cos 계수 받는 함수의 s, theta, zeta에서의 값
        integer, intent(in) :: xm(:), xn(:)   ! xs 자리에는 netcdf의 phi가 들어간다. (xs=nc.phi)
        real(8), intent(in) :: theta, zeta, s
        real(8), intent(in) :: xs(:)
        real(8), intent(in) :: coeff(:,:)        ! 2차원 계수 그대로 넣어줌(순서는 원래 계수, s 로 받음)
        real(8), intent(in) :: cosvals(:)        ! 미리 계산된 cos 값
        real(8) :: output
        integer :: istep
        integer :: xm_l

        xm_l = size(xm)
        output = 0.0d0
        do istep = 1, xm_l
            output = output + coeff(istep)  * cosvals(istep)
        end do
    end function compc

    function compc_arg(theta, zeta,xm,xn,coeff, cosvals) result(output)   ! cos 계수 받는 함수의 s, theta, zeta에서의 값
        integer, intent(in) :: xm(:), xn(:)   ! xs 자리에는 netcdf의 phi가 들어간다. (xs=nc.phi)
        real(8), intent(in) :: theta, zeta
        real(8), intent(in) :: coeff(:)        ! 2차원 계수 그대로 넣어줌(순서는 원래 계수, s 로 받음)
        real(8), intent(in) :: cosvals(:)        ! 미리 계산된 cos 값
        real(8) :: output

        integer :: istep
        integer :: xm_l

        xm_l = size(xm)
        output = 0.0d0
        do istep = 1, xm_l
            output = output + coeff(istep)  * cosvals(istep)
        end do
    end function compc_arg

    function compc_dtheta_arg(theta, zeta,xm,xn,coeff, sinvals) result(output)
        integer, intent(in) :: xm(:), xn(:)
        real(8), intent(in) :: theta, zeta

        real(8), intent(in) :: coeff(:)
        real(8), intent(in) :: sinvals(:)   ! 미리 계산된 sin 값
        real(8) :: output
        integer :: istep
        integer :: xm_l

        xm_l = size(xm)
        output = 0.0d0
        do istep = 1, xm_l
            output = output - coeff(istep) * xm(istep)*sinvals(istep)
        end do
    end function compc_dtheta_arg
    function compc_dzeta_arg(theta, zeta,xm,xn,coeff, sinvals) result(output)
        integer, intent(in) :: xm(:), xn(:)
        real(8), intent(in) :: theta, zeta
        real(8), intent(in) :: coeff(:)
        real(8), intent(in) :: sinvals(:)   ! 미리 계산된 sin 값
        real(8) :: output
        integer :: istep
        integer :: xm_l

        xm_l = size(xm)
        output = 0.0d0
        do istep = 1, xm_l
            output = output + coeff(istep) * (xn(istep)*0.5)*sinvals(istep)
        end do
    end function compc_dzeta_arg


    function comps_arg(theta2, zeta2,xm2,xn2,coeff2, sinvals2) result(output2)
        integer, intent(in) :: xm2(:), xn2(:)
        real(8), intent(in) :: theta2, zeta2

        real(8), intent(in) :: coeff2(:)
        real(8), intent(in) :: sinvals2(:)   ! 미리 계산된 sin 값
        real(8) :: output2
        integer :: istep2
        integer :: xm_l2

        xm_l2 = size(xm2)
        output2 = 0.0d0
        do istep2 = 1, xm_l2
            output2 = output2 + coeff2(istep2) * sinvals2(istep2)
        end do
    end function comps_arg

    subroutine crossp2(a,b,j,c)
        real(8), intent(in) :: a(3), b(3)
        real(8), intent(in) :: j
        real(8), intent(out) :: c(3)
        c(1) = (a(2)*b(3) - a(3)*b(2))/j
        c(2) = (a(3)*b(1) - a(1)*b(3))/j
        c(3) = (a(1)*b(2) - a(2)*b(1))/j
    end subroutine crossp2
end module fourier3